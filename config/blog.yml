title: "Actix Blog"
description: "A blog about stuff"
default: light-web-stack
posts:
  - slug: threads-rust
    title: "Threads in Rust"
    author: Neil Ulises
    date: 2022-10-23
    body: >
      Every program starts with the main thread only. This thread will execute your
      main function and can be used to spawn more threads if necessary.
      ```rust
        use std::thread;
        fn main() {
          thread::spawn(f);
          thread::spawn(f);
          println!("main thread");
        }
        fn f() {
          println!("another thread");
          let id = thread::current().id();
          println!("Thread id: {id:?}");
        }
      ```
      If we execute this code there is no guarantee that the main thread wait the
      execution of the others threads, you have to invoke the method **join()**.

      ```rust
        let t1 = thread::spawn(f);

        // Waits until the thread has finished executing and returns a std::thread::Result

        t1.join().unwrap();
      ```
      No longer a truncate output. But we still have a diferent order in which the messages
      are printed. The output locking in the println macro **std::io::Stdout::lock()** make
      sure its output doesn't get interrumped.
      Since a thread might run until the very end of the program's execution, the spawn
      function has a 'static lifetime bound on its argument type. In other words, it only
      accepts functions that may be kept around forever, since that reference would
      become invalid the moment the local variable ceases to exist.
      ```rust
        // Getting a value back out of the thread is done by returning it from
        // the clousure. This return value can be obtained from the Result returned
        // by the join method.
        let numbers = Vec::from_iter(0..=1000);

        let t = thread::spawn(move || {
          let len = numbers.len();
          let sum = numbers.into_iter().sum::<usize>();
          // value returned by the thread's clousure
          sum / len
        });

        let average = t.join().unwrap();
        println!("average: {average}");
      ```

      ## Thread Builder

      The spawn function is actually just a convenient shorthand for 
      **std::thread::Builder::new().spawn().unwrap()**. Builder allows you to
      set some settings for the new thread and to give the new thread before spawning it.
      You can use it to configure the **stack size or name**, this helps to debug,
      monitor and to recover more easily if panics a thread.

      ## Scoped Threads

      If we know for sure that a spawned thread will definitely not outlive a certain
      scope, that thread could safely borrow things that do not live forever, such as
      local variables, as long as they outlive that scope.
      ```rust
        let numbers = vec![1,2,3];

        thread::scope(|s| {
          // When the scope ends, all threads that haven't been joined yet are automatically joined.
          s.spawn(|| {
            println!("length: {}", numbers.len());
          });
          s.spawn(|| {
            for n in &numbers {
              println!("{n}");
            }
          })
        })
      ```
      Both threads are concurrently accessing numbers. But will drop error if we
      change in one of them or in the main thread. Something to highlight is a big
      error design in the **Rust 1.0** with a function named scoped, it allowed
      non static captures because returned a JoinGuard instead of a JoinHandle,
      which joined the thread when dropped. Any borrowed data only needed to outlive
      this JoinGuard. Without guarantee that something will be dropped.
      [The Leakpocalypse](https://cglab.ca/~abeinges/blah/everyone-poops/) improve
      the design for safety interface like **std::mem::forget** was upgraded to a
      safe function, to emphatize that forgetting (or leaking) is always a possibility.
      Or **scoped** was redisign that doesn't rely on **Drop** for correctness.

      ## Shared Ownership and Reference Counting

      When sharing data between two threads where neither thread is guaranteed to outlive
      the other, neither of them can be the owner of that data. Any data shared
      between them will need to live as long as the longest living thread.
      To make sure that shared data gets dropped and deallocated, we can't completely
      give up its ownership. Instead, we can share ownership. By keeping track
      of the number of owners, we can make sure the value is dropped only when
      there are no owners left.
      Rc is very similar to a **Box**, except cloning it will not allocate anything
      new, but instead increment a counter stored next to the contained value.
      Both the original and cloned Rc will refer to the same allocation; they share
      ownership.
      ```rust
        use std::rc::Rc;
        let a = Rc::new([1, 2, 3]);
        let b = a.clone();
        assert_eq!(a.as_ptr(), b.as_ptr()); // Same allocation!

        // Rc is not thread safe, instead we can use Arc that guarantees that
        // modifications to the reference counter are indivisible atomic operations,
        // making it safe to use it with multiple threads.
        use std::sync::Arc;
        let a = Arc::new([1,2,3]);
        // Cloning the Arc increments the reference count to two and provides us
        // with a second Arc to the same allocation.
        let b = a.clone();
        thread::spawn(move || dbg!(a));
        // Decrement the Arc to 0 and deallocate the array
        thread::spawn(move || dbg!(b));
      ```
      ![naming_clones](/images/arc.png)

      ## Borrowing and Data Races

      In rust, values can be borrowed in two ways:
      ## Immutable borrowing

      Borrowing something with & gives an immutable reference. Such a reference
      can be copied. Access to the data it references is shared between all copies
      of such a reference. But you can't mutate something through such a reference.
      That might affect other code that's currently borrowing the same data.
      ## Mutable borrowing

      Borrowing something with &mut gives a mutable reference. A mutable borrow
      guarantees it's the only active borrow of that data. This ensures that mutating
      the data will not change anything that other code is currently looking at.
      These two concepts together fully prevent **data races**.

  - slug: light-web-stack
    title: "Great combo in web development"
    author: Neil Campos
    date: 2023-11-07
    body: >
      The stack([Turso](https://turso.tech/), [Htmx](https://htmx.org/), [K3s](https://k3s.io/)),
      You pick the backend language that you want :).

      ## HTMX

      This post only pretend that you ask yourself if the stack that you are using
      is the appropriate in terms of fast delivery and prototyping, and with this said
      my principal issue with modern's frontends(React, Vue...) is that seems that is
      the best option by default, when if you are not creating a heavy client's
      like a spreadsheet or when you really need to have a site offline, maybe is 
      complexity that it's not necessary.
      Years before react towards sense with the SPA and make changes without refresh
      the page, but with libs like htmx tackle this and gives really power to html
      that allow you to focus in your business logic and still having a good client
      experience, the main advantages are:
       * Take away a lot of space in the docker image with 14k of the lib
       * No maintain 2 codebases
       * No decoding and encoding JSON
       * No replicate 2 states
       * Just return html and make real [RESTful](https://htmx.org/essays/how-did-rest-come-to-mean-the-opposite-of-rest/) with SPA benefits

      ![why-htmx](/images/why-htmx.png)

      ## Js is good but not in everything

      This seems a skill issue or a hate to the javascript ecosystem but even
      they are considering more server components with the only incovenient that
      you are tied to build the backend in the environment that they offer like
      with Vercel. All the Js ecosystem it's not going anywhere but there is
      another solutions that makes things more simple when you have to build an
      entire solution that require a solid data model and backend to success!.

      ## Turso

      Is a [fork](https://turso.tech/libsql) of sqlite in the edge
      that comparing with others solutions have the best free plan to build your
      product. Am not a big fan to start for example with a NoSQL solution to start
      something quick, I prefer invest time in create a good schema for the business
      needs and use SQL in the begin with no need to maintain a super database like postgres.
      The [multitenancy](https://turso.tech/multitenancy) is a good reason to build
      a saas on it, to show how simple it is, this 2 commands:

      ```sh
        # Replicate a DB for a client to Tokio
        turso db replicate db_name nrt
        # Get the data for a client
        turso db shell org-zjhg3lp .dump > org.data
      ```

      ## Embedded replicas

      Provide a smooth switch between local and remote database operations, allowing
      the same database replicate in local for reads and the writes for remote, 
      and sync when you really need it.

      ## Platform API

      A RESTful api that allows you to change databases, replicas, and users without
      managing database infrastructure and replication. A simple example:

      ```js
        public databases: DatabaseAPI = {
          create: ({ name, location, image, group }) =>
            this.fetch("/v1/databases", {
            method: "POST",
            body: JSON.stringify({
              name,
              location,
              group,
            }),
          }),
        };
      ```

      ## K3s

      K3s complement really well in our light stack that doesn't mean that can't
      scale, turso and k3s are focus to embedded systems but you can create large
      clusters with high-availability setup and an external database for etcd, and
      for turso replicas and multitenancy technique.
      To manipulate your infrastructure am not 100% sure that kubernates is really
      the more simple to work with, Also with solutions like [fly.io](https://fly.io/)
      or [shuttle](https://www.shuttle.rs/) are good options to not interact directly
      with all the complexity of the infrastructure. But I will argue that know how to
      manipulate containers, It will give you advantages in the future.
      I really encourage to create your own lab with minimum hardware and have fun testing your
      services.

      ## What k3s does for you

      For a simple developer like me that in the first time that install k8s
      and use it to deploy a little server with a database was overwhelming that's why
      I opted for k3s, It gives you all preconfigured in a single binary of about 45MB
      that completely implements the Kubernates API's. To ensure lightness they
      removed a lot of extra drivers that are not strictly part of the core, but
      still easily replaceable with external add ons.
       * increase performance
       * lower cost giving you the portability and the scalability that's assoiciated with cloud native applications
       * Internally managed Etcd cluster
       * Internally managed TLS communications
       * Internally managed certificate rotation and distribution
       * Integrated storage provider(localpath provisioner)
       * Low dependency on base operating system

      ![arch](/images/arch.svg)
